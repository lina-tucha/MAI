#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Хренникова А.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Некоторые задачи можно представить в виде пары из множества некоторых доступных состояний и множества переходов между этими состояниями(то есть, в виде графа состояний). Для решения задач, представимых в таком виде, решением является путь в графе от начальной вершины до конечной. Основными стратегиями решения являются алгоритмы поиска в графах - поиск в глубину, поиск в ширину и поиск с итерационным заглублением. Вышеописанные задачи также называют задачами на поиск в пространстве состояний.

В языке Prolog удобнее всего описывать граф предикатами, с помощью явного перечисления всех дуг в виде пар вершин. Такие дуги можно задавать не только явным перечислением, но и с помощью некоторых правил, что делает возможным описание достаточно больших и сложных графов.

## Задание

Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара. Передвинуть черные шары на место белых, а белые - на место черных. Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредственно за ближайшим шаром.

## Принцип решения

Для решение задачи я использовала поиск в глубину, ширину и с итерационным погружением.

Чтобы черные и белые шары поменялись местами, нужно либо переставлять шары на соседние свободные лунки, либо перепрыгивать шарами через один. Стоит заметить, что если решений будет несколько - они будут симметричны.

```Prolog
%правила для перемещения шаров
move([B1,B2,B3,B4,B5,B6,B7],List):-
        (B1=space,List=[B2,space,B3,B4,B5,B6,B7]);
        (B1=space,List=[B3,B2,space,B4,B5,B6,B7]);

        (B2=space,List=[B1,B3,space,B4,B5,B6,B7]);
        (B2=space,List=[B1,B4,B3,space,B5,B6,B7]);
        (B2=space,List=[space,B1,B3,B4,B5,B6,B7]);

        (B3=space,List=[B1,B2,B4,space,B5,B6,B7]);
        (B3=space,List=[B1,space,B2,B4,B5,B6,B7]);
        (B3=space,List=[B1,B2,B5,B4,space,B6,B7]);
        (B3=space,List=[space,B2,B1,B4,B5,B6,B7]);

        (B4=space,List=[B1,B2,B3,B5,space,B6,B7]);
        (B4=space,List=[B1,B2,space,B3,B5,B6,B7]);
        (B4=space,List=[B1,space,B3,B2,B5,B6,B7]);
        (B4=space,List=[B1,B2,B3,B6,B5,space,B7]);

        (B5=space,List=[B1,B2,space,B4,B3,B6,B7]);
        (B5=space,List=[B1,B2,B3,space,B4,B6,B7]);
        (B5=space,List=[B1,B2,B3,B4,B6,space,B7]);
        (B5=space,List=[B1,B2,B3,B4,B6,B7,space]);

        (B6=space,List=[B1,B2,B3,B4,space,B5,B7]);
        (B6=space,List=[B1,B2,B3,space,B5,B4,B7]);
        (B6=space,List=[B1,B2,B3,B4,B5,B7,space]);

        (B7=space,List=[B1,B2,B3,B4,space,B6,B5]);
        (B7=space,List=[B1,B2,B3,B4,B5,space,B6]).

%продление пути с предотвращением петель
prolong([L|List],[Y,L|List]):-
        move(L,Y),
        not(member(Y, [L|List])).

%печать пути
printer([]).
printer([L|List]):-
        write(L),nl,
        printer(List).

%поиск в ширину
search_width(Begin,End):-
        get_time(B1),
        width([[Begin]],End,Path),
        reverse(Path,P),
        get_time(E1),
        TIME1 is E1 - B1,
        nl,write('Time: '), write(TIME1),nl,!,
        printer(P), nl, !.

width([[B|Queue]|_],B,[B|Queue]).
width([Q|Qi],B,Path):-
        findall(Tmp,prolong(Q,Tmp),TmpPath),
        append(Qi,TmpPath,Qo),!,
        length(Qo,Len),
        Len<1000,
        width(Qo,B,Path),!.
width([_|T],Y,L):-
        width(T,Y,L).

%поиск в глубину
search_depth(Begin,End):-
        get_time(B2),
        depth([Begin],End,Path),
        reverse(Path,P),
        get_time(E2),
        TIME2 is E2 - B2,
        nl,write('Time: '), write(TIME2),nl,!,
        printer(P),!.

depth([B|List],B,[B|List]).
depth([L|List],B,Path):-
        prolong([L|List],Res),
        depth(Res,B,Path).

%поиск с итеративным погружением
integer1(1).
integer1(X):-
    integer1(Y),
    X is Y + 1.

search_id(Begin,End):-
        get_time(B3),
        integer1(Depth),
        id([Begin],End,Path,Depth),
        reverse(Path,P),
        get_time(E3),
        TIME3 is E3 - B3,
        nl,write('Time: '), write(TIME3),nl,!,
        printer(P),!.

id([B|List],B,[B|List],_).
id([L|List],B,Path,Depth):-
        prolong([L|List],Res),
        length(Res,Len),
        Len<Depth,
        id(Res,B,Path,Depth).
```

## Результаты

```
?- search_id([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).

Time: 1.5906898975372314
[w,w,w,space,b,b,b]
[w,w,w,b,space,b,b]
[w,w,space,b,w,b,b]
[w,space,w,b,w,b,b]
[w,b,w,space,w,b,b]
[w,b,w,b,w,space,b]
[w,b,w,b,w,b,space]
[w,b,w,b,space,b,w]
[w,b,space,b,w,b,w]
[space,b,w,b,w,b,w]
[b,space,w,b,w,b,w]
[b,b,w,space,w,b,w]
[b,b,w,b,w,space,w]
[b,b,w,b,space,w,w]
[b,b,space,b,w,w,w]
[b,b,b,space,w,w,w]
true.

?- search_depth([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).

Time: 0.0014619827270507812
[w,w,w,space,b,b,b]
[w,w,w,b,space,b,b]
[w,w,space,b,w,b,b]
[w,w,b,space,w,b,b]
[w,w,b,w,space,b,b]
[w,w,b,w,b,space,b]
[w,w,b,space,b,w,b]
[w,w,b,b,space,w,b]
[w,w,space,b,b,w,b]
[w,space,w,b,b,w,b]
[w,b,w,space,b,w,b]
[w,b,w,b,space,w,b]
[w,b,space,b,w,w,b]
[w,b,b,space,w,w,b]
[w,b,b,w,space,w,b]
[w,b,space,w,b,w,b]
[w,space,b,w,b,w,b]
[space,w,b,w,b,w,b]
[b,w,space,w,b,w,b]
[b,w,w,space,b,w,b]
[b,w,w,b,space,w,b]
[b,w,space,b,w,w,b]
[b,w,b,space,w,w,b]
[b,w,b,w,space,w,b]
[b,w,b,w,w,space,b]
[b,w,b,w,w,b,space]
[b,w,b,w,space,b,w]
[b,w,space,w,b,b,w]
[b,w,w,space,b,b,w]
[b,w,w,b,space,b,w]
[b,w,space,b,w,b,w]
[b,w,b,space,w,b,w]
[b,space,b,w,w,b,w]
[b,b,space,w,w,b,w]
[b,b,w,space,w,b,w]
[b,b,w,w,space,b,w]
[b,b,w,w,b,space,w]
[b,b,w,space,b,w,w]
[b,b,w,b,space,w,w]
[b,b,space,b,w,w,w]
[b,b,b,space,w,w,w]
true.

?- search_width([w,w,w,space,b,b,b],[b,b,b,space,w,w,w]).
false.
```

| Алгоритм поиска |  Длина найденного первым пути  |         Время работы        |
|-----------------|--------------------------------|-----------------------------|
| В глубину       |               41               |    0.0014619827270507812    |
| В ширину        |     выход за пределы стека     |              -              |
| ID              |               16               |      1.5906898975372314     |

Поиск в глубину показал минимальное время работы, но нашел длинный путь. При поиске в ширину переполнился стек, потому что длина очереди содержала большое количество списков. Поиск с итерационным погружением нашел самый короткий путь, но работал значительно дольше поиска в глубину. 

## Выводы

В результате данной лабораторной работы, я узнала много нового об алгоритмах поиска в графах и об их реализациях в языке Prolog.

Благодаря лаконичности Prolog, алгоритмы поиска реализуются на нем гораздо проще, чем на императивных языках. Во время выполнения данной лабораторной работы, я научилась реализовывать все алгоритмы поиска в графах(поиск в ширину, поиск в глубину, поиск с итерационным погружением).

Сравним используемые алгоритмы. Поиск в глубину всегда идёт по первой ветви дерева до самой глубокой вершины и возвращается только при тупике или поиске других решений. Поиск в ширину же сначала обходит все пути длины 1, потом 2 и т.д.. В общем случае, поиск в глубину требует сравнительно небольшой объём памяти, но, в случае бесконечного дерева, он может легко зациклиться и не найти решений. Поиск в ширину, наоборот, подходит для бесконечных деревьев, однако требует большего объема памяти. А вот алгоритм поиска с итерационным заглублением сочетает в себе преимущества и недостатки двух предыдущих алгоритмов. Он не уступает по памяти поиску в глубину и не уступает по сложности поиску в ширину. Плата за это - небольшие потери в производительности.

Для моей задачи абсолютно не подходит поиск в ширину, потому что для него требуется много памяти, если же необходимо найти кратчайший путь, то нужно использовать поиск с итерационным погружением, а если требуется быстрое нахождение решения, то нужно использовать поиск в глубину.
