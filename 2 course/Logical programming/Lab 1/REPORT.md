# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Хренникова А. С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     5-        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки являются основой для организации всех сложных вычислений. Одно из основных свойств списка – отсутствие ограничений на элементы и размер списка. Вложенность списков также ничем не ограничивается. Список в prolog можно представить в виде двоичного дерева, в листоях которого находятся элементы списка или пустой список. Элементами списка могут быть любые объекты. То есть он либо пуст, либо состоит из двух частей: головы и хвоста, который сам является списком.
Списки соответствуют, грубо говоря, массивам в других языках, но, в отличие от массивов, к элементам мы не имеем произвольный доступ. Еще одним отличием списков в prolog от списков в императивных языках в том, что их обработка в prolog может быть осуществлена только рекурсивно, постепенно разделяя список на голову и хвост.

## Задание 1.0: Реализация стандартных предикатов

```prolog
%Длина списка
%(список, длина)
my_length([], 0).
my_length([_|L], N):-
        my_length(L, N1), N is N1+1.

%Отношение принадлежности
%(элемент, список)
my_member(E, [E|_]).
my_member(E, [_|R]):-
        my_member(E, R).

%Конкатенация списков
%(список 1, список 2, список 1 + список 2)
my_append([], L, L).
my_append([X|T], L2, [X|R]):-
        my_append(T, L2, R).

%Удаление элемента из списка
%(элемент, список, список без элемента)
my_remove(X, [X|T], T).
my_remove(X, [Y|T], [Y|Z]):-
        my_remove(X, T, Z).

%Проверка является ли первый список подсписком второго
%(подсписок, список)
my_sublist(S, L):-
        my_append(_, L1, L),
        my_append(S, _, L1).

%Перестановки
%(список, перестановка)
my_permute([],[]).
my_permute(L, [X|T]):-
        my_remove(X, L, Y),
        my_permute(Y, T).
```

## Задание 1.1: Предикат обработки списка

`ins_in_pos(X, List, P, Result)` - вставляет элемент X в список List на Р позицию, Result - результирующий список.

Примеры использования:
```prolog
?- ins_in_pos(5, [0, 1, 2, 3], 3, K).
K = [0, 1, 5, 2, 3].

?- ins_in_pos(X, [A, B, C, D, T], 1, K).
K = [X, A, B, C, D, T].

?- ins_in(4, [0, 1, 2, 3], 1, K).
K = [4, 0, 1, 2, 3].
```

Реализация:
```prolog
%без использования стандартных предикатов
%(элемент, список без элемента, позиция, список с элементом)
ins_in_pos(X, [H|L], P, [H|R]):-
        P > 1,
        !,
        P1 is P - 1,
        ins_in_pos(X, L, P1, R).
ins_in_pos(X, L, 1, [X|L]).

%с использованием стандартных предикатов
ins_in(X, L, P, R):- 
        prefix(PR, P),
        my_length(PR, L),
        my_append(PR, PO, P),
        my_append(PR, [X|PO], R).
```

Каждый элемент, находящийся слева от позиции, на которую мы хотим вставить, помещается в начало результирующего и удаляется из исходного. Когда мы доходим до нужной позиции, то к результирующему списку добавляется необходимый элемент и оставшиеся элементы списка.  

## Задание 1.2: Предикат обработки числового списка

`geom_seq(List)` - проверяет эсписок на геометрическую прогресию.

Примеры использования:
```prolog
?- geom_seq([1, 2, 4, 8, 16]).
true.

?- geom([1, 2]).
true.

?- geom([1, 2, 5]).
false.
```

Реализация:
```prolog
%без использования стандартных предикатов
%(список)
geom_seq([X,Y,Z|T]) :-
        !,
        (Y * Y) =:= (X * Z),
        geom_seq([Y,Z|T]).
geom_seq(_).

%с использованием стандартных предикатов
geom([X,Y,Z|T]) :-
        !,
        (Y * Y) =:= (X * Z),
        my_remove(X, [X,Y,Z|T], R),
        geom(R).
geom(_).
```

Предикат выделяет первые три числа из списка и проверяет их на геометрическую прогрессию, то есть произведение первого и третьего должно быть равно квадрату второго. После удаляет первое число из списка и с помощью рекурсии продолжает свою работу, то есть снова выделяет три первых числа и т.д., до тех пор, пока может выделить числа из списка(количество элементов в списке больше или равно трем).

## Задание 2: Реляционное представление данных

Реляционное представление - представление, основанное на отношениях между объектами, такое представление также часто называют табличным. При запросе к реляционной структуре, ответом является некоторое множество объектов. Такая модель отображает данные в достаточно простой и понятной форме. С данными в реляционном представлении удобно работать, используя логические и функциональные языки программирования.

В моем варианте представления(one.pl) отношения представлены таким образом: student(102,'Петров'). subject('LP','Логическое программирование'). grade('Петров','LP',4).

Данное представление не очень удобное для моего варианта заданий, потому что при создании списка групп или предметов для учеников будут дублироваться элементы, а их нужно удалять. 

1. Получить таблицу групп и средний балл по каждой из групп:
`sum(X, Y)` - вычисляет сумму элементов списка.
`arithm_mean(X, Y)` - вычисляет среднее арифметическое значение элементов списка.
`mark(X, Y)` - получает оценку студента по предмету.
`student_point_average(X, Y)` - получает средний балл ученика по всем предметам.
`students_point_average_in_group(X, Y)` - получает средний балл ученика в группе.
`group_point_average_print()` - печатает средний балл для каждой группы.

2. Для каждого предмета получить список студентов, не сдавших экзамен (grade=2):
`repass(X, Y)` - получет студента, не сдавшего предмет.
`print_repass()` - печатает предметы и списки не сдавших данные предметы.

3. Найти количество не сдавших студентов в каждой из групп:
`group_repass(X, Y)` - получает не сдавших студентов в какой-либо группе.
`num_repass_in_group(X, Y)` - подсчитывает количество не сдавших студентов в группе.
`print_num_repass()` - печатает номер группы и количество несдавших студентов.

Реализация:
```prolog
%Получить таблицу групп и средний балл по каждой из групп

sum([], 0).
sum([X|Y], S) :-
        sum(Y, Q),
        S is Q + X.

arithm_mean(X, T) :-
        length(X, L),
        sum(X, P),
        T is P / L.

mark(Student, N) :-
        grade(Student, _, N).

student_point_average(Student, Res) :-
        findall(N, mark(Student, N), List),
        arithm_mean(List, Res).

students_point_average_in_group(Group, Res) :-
        student(Group, Stud),
        student_point_average(Stud, Res).

group_point_average_print() :-
        findall(Group, student(Group, _), BadListGroup),
        sort(BadListGroup, ListGroup),
        member(Group2, ListGroup),
        setof(Res, students_point_average_in_group(Group2, Res), ListValue),
        arithm_mean(ListValue, Ans),
        write('Группа: '), write(Group2), write(' Средний балл: '), write(Ans), write('\n'), fail.

%Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)

repass(Subj, Name) :-
        subject(X, Subj),
        grade(Name, X, 2).

print_repass() :-
        subject(_, Subj),
        findall(Name, repass(Subj, Name), List),
        write('Предмет: '), write(Subj), write(' Не сдали: '), write(List), write('\n'), fail.

%Найти количество не сдавших студентов в каждой из групп

group_repass(Group, Name) :-
        student(Group, Name),
        grade(Name, Y, 2).

num_repass_in_group(Group, Num) :-
        findall(Name, group_repass(Group, Name), List),
        length(List, Num).

print_num_repass() :-
        findall(X, student(X, _), BadGroup),
        sort(BadGroup, NoBadGroup),
        member(Group, NoBadGroup),
        num_repass_in_group(Group, Num),
        write('Группа: '), write(Group), write(' Несдавших: '), write(Num), write('\n'), fail.
```

Пример работы:
```prolog
?- group_point_average_print.
Группа: 101 Средний балл: 3.916666666666667
Группа: 102 Средний балл: 3.7291666666666665
Группа: 103 Средний балл: 3.6
Группа: 104 Средний балл: 3.7916666666666665
false.

?- print_repass.
Предмет: Логическое программирование Не сдали: [Запорожцев,Эфиркина,Текстописов]
Предмет: Математический анализ Не сдали: [Запорожцев,Круглосчиталкин,Густобуквенникова,Криптовалютников,Блокчейнис,Азурин]
Предмет: Функциональное программирование Не сдали: [Криптовалютников]
Предмет: Информатика Не сдали: [Эфиркина,Джаво,Безумников]
Предмет: Английский язык Не сдали: [Эфиркина]
Предмет: Психология Не сдали: [Биткоинов,Текстописова,Криптовалютников,Азурин,Вебсервисов]
false.

?- print_num_repass.
Группа: 101 Несдавших: 2
Группа: 102 Несдавших: 7
Группа: 103 Несдавших: 5
Группа: 104 Несдавших: 5
false.
```

## Выводы

При программировании на языке prolog нужно совсем иначе мыслить при написании программы, в отличии, например, от программирования на императивных языках. Сложность заключается в том, что предикаты это не функции и они не возвращают значения и могут вызываться в нескольких режимах. Интересны также такие возможности, как бектрекинг и унификация. Все эти возможности позволяют писать меньше кода, чем на том же Си, но и код получается не в виде набора команд, а в виде определений. Другими словами, мы не говорим машине делай одно действие, затем другое и так далее, а мы просто говорим, например, сумма в нашем понимании определется вот так. Также в prolog интересная реализация списков. Элементами списка тут могут быть любые структуры. И как показала вторая часть лабораторной работы из реляционного представления данных на prolog можно легко и быстро доставать любую информацию. В итоге на prolog очень коротко можно написать многие вещи, которые занимали бы на других языках больше кода, но чтобы написать эти вещи нужно думать не в процедурном стиле, а в декларативном.
